<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fibonacci Playground by Evan Marie Carr</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #131924;
            color: #e2e8f0;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }

        .container:active {
            cursor: grabbing;
        }

        .overlay {
            position: absolute;
            inset: 0;
            background: rgba(67, 56, 202, 0.1);
            pointer-events: none;
            z-index: 10;
        }

        .controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 6vh;
            display: flex;
            align-items: center;
            padding: 0 2vh;
            background: rgba(19, 25, 36, 0.6);
            backdrop-filter: blur(10px);
        }

        .sliders {
            display: flex;
            align-items: center;
            justify-content: space-evenly;
            width: 70%;
            height: 100%;
        }

        .slider-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.2vh;
        }

        .slider-label {
            color: #feb1ff;
            font-size: 1.1vh;
            text-shadow: 0 0.1vh 0.2vh rgba(0, 0, 0, 0.5);
        }

        .slider {
            width: 8vh;
            height: 0.4vh;
            background: #374151;
            border-radius: 0.2vh;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 1.6vh;
            height: 1.6vh;
            background: #00fff7;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0.2vh 0.4vh rgba(0, 0, 0, 0.3);
        }

        .slider::-moz-range-thumb {
            width: 1.6vh;
            height: 1.6vh;
            background: #6366f1;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0.2vh 0.4vh rgba(0, 0, 0, 0.3);
        }

        .animation-controls {
            width: 30%;
            height: 100%;
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }

        .control-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.3vh;
            background: none;
            border: 0.2vh transparent;
            color: #feb1ff;
            cursor: pointer;
            padding: 0.4vh;
            border-radius: 0.8vh;
            transition: all 0.2s;
        }

        .control-button:hover {
            background: rgba(99, 102, 241, 0.2);
            transform: translateY(-0.1vh);
        }

        .control-button.active {
            background: rgba(38, 40, 138, 0.3);
            border: 0.2vh solid #00f2ff;
            color: #00f2ff;
        }

        .control-label {
            font-size: 0.9vh;
            text-shadow: 0 0.1vh 0.2vh rgba(0, 0, 0, 0.5);
        }

        .title-text {
            font-size: 2.5vh;
            text-shadow: 0 0.1vh 0.2vh rgba(0, 0, 0, 0.5);
            font-weight: 500;
            color: #00f2ff;
            position: absolute;
            top: 0.5vh;
            left: 1vh;
            z-index: 400;
            display: flex;
            flex-direction: column;
            gap: 0.3vh;
            font-family: Quicksand;

        }

        .control-icon {
            width: 3vh;
            height: 3vh;
            border-radius: 50%;
            background: #4f46e5;
            border: 0.2vh solid #00f2ff;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fecfff;
            font-size: 2.5vh;
            box-shadow: 0 0.2vh 0.4vh rgba(0, 0, 0, 0.3);
        }

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.open {
            display: flex;
        }

        .modal-content {
            background: rgb(34, 30, 71);
            border-radius: 3vh;
            font-size: 1.5vh;
            max-width: 100svh;
            max-height: 90vh;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.5);
            font-family: Quicksand;
            position: relative;
            display: flex;
            flex-direction: column;

        }

        .modal-header {
            padding: 1.5vh 2.5vh;
            border-bottom: 1px solid #374151;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(19, 25, 36, 0.6);
            backdrop-filter: blur(10px);
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            border-radius: 3vh 3vh 0 0;
        }

        .modal-title {
            font-size: 3.5vh;
            font-weight: bold;
            color: #00f7ff;
        }

        .close-button {
            background: none;
            border: none;
            color: #00eaff;
            cursor: pointer;
            font-size: 3vh;
            padding: 1vh;
            border-radius: 3vh;
            transition: color 0.2s;
        }

        .modal-footer {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 16px 24px;
            border-top: 1px solid #374151;
            display: flex;
            justify-content: center;
            background: rgba(19, 25, 36, 0.6);
            backdrop-filter: blur(10px);
            z-index: 1000;
            border-radius: 0 0 3vh 3vh;
        }

        .modal-close-btn {
            background: #00fff7;
            border: none;
            border-radius: 4vh;
            color: rgb(30, 40, 47);
            cursor: pointer;
            font-size: 1.7vh;
            padding: 0.5vh 2vh;
            transition: all 0.2s;
            font-weight: 500;
        }

        .modal-close-btn:hover {
            background: hsl(179, 100%, 50%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .modal-body {
            height: 100%;
            margin: 8.5vh 0 4.5vh 0;
            padding: 3vh;
            line-height: 1.6;
            overflow-y: auto;
            flex: 1;
            gap: 1vh;

        }

        .hr {
            width: 100%;
            border: 0.1vh solid rgba(80, 217, 255, 0.2);
            margin: 3vh 0;
        }

        .section {
            margin-bottom: 3vh;
        }

        .section-title {
            font-size: 2.5vh;
            font-weight: bold;
            color: #ffd0f4;
            margin-bottom: 16px;
        }

        .section-content {
            color: #cbd5e1;
        }

        .section-content p {
            margin-bottom: 12px;
        }

        .section-content strong {
            color: #e2e8f0;
        }

        .section-content ul {
            margin: 12px 0;
            padding-left: 20px;
        }

        .section-content li {
            margin-bottom: 8px;
        }

        .formula {
            background: #1d2435;
            border: 1px solid #334155;
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            text-align: center;
            font-family: 'Roboto Mono', monospace;
            font-size: 1.8vh;
            color: #befeff;
        }
    </style>
</head>

<body>

    <div class="container" id="container">
        <div class="title-text">
            <p>Fibonacci Playground </p>
            <p style="font-size: 2vh;">by Evan Marie Carr</p>
            <a href="https://github.com/EvanMarie" target="_blank" style="color: rgb(255, 200, 253);">
                <p style="font-size: 1.5vh;">https://github.com/EvanMarie</p>
            </a>
        </div>
        <div class="overlay"></div>
        <canvas id="canvas"></canvas>

        <div class="controls">
            <div class="sliders">
                <div class="slider-group">
                    <label class="slider-label">radius</label>
                    <input type="range" class="slider" id="radiusSlider" min="0.5" max="3.0" step="0.01" value="1.2">
                </div>
                <div class="slider-group">
                    <label class="slider-label">depth</label>
                    <input type="range" class="slider" id="depthSlider" min="0.0" max="3.0" step="0.01" value="1.0">
                </div>
                <div class="slider-group">
                    <label class="slider-label" id="nodesLabel">nodes: 333</label>
                    <input type="range" class="slider" id="nodesSlider" min="6" max="500" step="1" value="333">
                </div>
                <div class="slider-group">
                    <label class="slider-label">zoom</label>
                    <input type="range" class="slider" id="zoomSlider" min="2" max="159" step="1" value="108">
                </div>
                <div class="slider-group">
                    <label class="slider-label">speed</label>
                    <input type="range" class="slider" id="speedSlider" min="0.1" max="3.0" step="0.1" value="1.0">
                </div>
            </div>

            <div class="animation-controls">
                <button class="control-button" id="infoBtn">
                    <div class="control-icon">i</div>
                    <span class="control-label">info</span>
                </button>
                <button class="control-button" id="resetBtn">
                    <div class="control-icon">↻</div>
                    <span class="control-label">reset</span>
                </button>
                <button class="control-button" id="breatheBtn">
                    <div class="control-icon">○</div>
                    <span class="control-label">breathe</span>
                </button>
                <button class="control-button" id="spinBtn">
                    <div class="control-icon">↺</div>
                    <span class="control-label">spin</span>
                </button>
                <button class="control-button" id="nodeCountBtn">
                    <div class="control-icon">#</div>
                    <span class="control-label">count</span>
                </button>
                <button class="control-button" id="numbersBtn">
                    <div class="control-icon">
                        <svg width="2.2vh" height="2.2vh" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                            stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z" />
                            <circle cx="12" cy="12" r="3" />
                        </svg>
                    </div>
                    <span class="control-label">numbers</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Modal -->
    <div class="modal" id="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">Fibonacci Mandala</h2>
                <button class="close-button" id="closeModal">×</button>
            </div>
            <div class="modal-footer">
                <button class="modal-close-btn" id="closeModalBottom">Close</button>
            </div>
            <div class="modal-body">

                <div class="section">
                    <h3 class="section-title">The Mathematics of Natural Patterns</h3>
                    <div class="section-content">
                        <p>You are exploring one of the most fundamental patterns in nature - a mathematical arrangement
                            that governs how sunflowers pack their seeds, how pinecones organize their scales, and how
                            galaxies form their spiral arms. This is phyllotaxis, and it reveals deep connections
                            between mathematics, physics, and biology.</p>
                        <p><strong>What you're seeing:</strong> Each point in your spiral is positioned according to
                            precise mathematical rules that optimize packing efficiency and resource distribution. As
                            you interact with the controls, you're experimenting with the same principles that shape
                            living systems.</p>
                    </div>
                </div>

                <hr class="hr">

                <div class="section">
                    <h3 class="section-title">The Golden Angle: Nature's Optimal Solution</h3>
                    <div class="section-content">
                        <p><strong>The fundamental question:</strong> If you were designing a sunflower, what angle
                            should you rotate between placing each seed to achieve maximum packing efficiency?</p>
                        <p>The answer is not intuitive. Simple fractions of a full rotation create inefficient radial
                            spokes, but the golden angle provides optimal spiral patterns. Its "magic" comes from being
                            the most irrational number, meaning it's the hardest to approximate with a simple fraction.
                            This property ensures that as new points are added, they never align, forcing them into the
                            tightest possible spiral.</p>
                        <div class="formula">Golden Angle = 360°/φ<sup>2</sup> ≈ 137.508°</div>
                        <p>This angle avoids creating regular patterns at any scale, ensuring optimal space utilization
                            as your spiral demonstrates. The golden angle emerges from the golden ratio φ, providing the
                            most mathematically efficient rotation possible for growth.</p>
                    </div>
                </div>
                <hr class="hr">
                <div class="section">
                    <h3 class="section-title">Phyllotaxis: The Universal Growth Pattern</h3>
                    <div class="section-content">
                        <p><strong>Biological foundation:</strong> Phyllotaxis describes how plants arrange leaves,
                            seeds, and branches to maximize access to sunlight and space. This visualization is a direct
                            model of that process.</p>
                        <p>The pattern follows two fundamental mathematical principles executed for every single point:
                        </p>
                        <p><strong>1. Angular Divergence</strong></p>
                        <div class="formula">θ = n × 137.508°</div>
                        <p>Each new element rotates by the exact same golden angle from its predecessor. This constant,
                            irrational turn ensures no two elements ever align radially, preventing gaps and maximizing
                            exposure.</p>
                        <p><strong>2. Radial Expansion</strong></p>
                        <div class="formula">r = k&radic;n</div>
                        <p>The distance from the center grows as the square root of the element's position number. This
                            specific relationship is crucial, as it guarantees that the density of points remains
                            constant
                            as the pattern expands outward. Use your radius slider to see how this mathematical
                            relationship maintains perfect proportions at any scale.</p>
                    </div>
                </div>
                <hr class="hr">
                <div class="section">
                    <h3 class="section-title">The Fibonacci Sequence: Hidden Order in Apparent Chaos</h3>
                    <div class="section-content">
                        <p><strong>Remarkable discovery:</strong> Although the spiral is generated using only the golden
                            angle, the famous Fibonacci sequence emerges spontaneously in the visual pattern. The model
                            does not use the Fibonacci numbers to place points; they are a consequence of the underlying
                            geometry.</p>
                        <p>The Fibonacci sequence appears because its ratio is the best whole-number approximation of
                            the
                            golden ratio:</p>
                        <div class="formula">F<sub>n</sub>: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55...</div>
                        <div class="formula">lim<sub>n→∞</sub> F<sub>n+1</sub>/F<sub>n</sub> = φ ≈ 1.618</div>
                        <p><strong>Observing Fibonacci Spirals</strong></p>
                        <p>Activate the "Spiral Spin" animation and look carefully. You'll see two sets of interlocking
                            spiral arms: one curving clockwise, another counterclockwise. Count the arms in each
                            direction—these numbers will be consecutive Fibonacci numbers, such as 21 and 34. This is
                            the
                            hidden mathematical order made visible.</p>
                        <p><strong>Dynamic Node Count Animation</strong></p>
                        <p>Try the "Node Count" animation to see how the spiral grows and shrinks dynamically. This
                            demonstrates the growth process of natural systems, where new elements are added
                            sequentially
                            following the golden angle. Watch as the pattern maintains its mathematical perfection at
                            every
                            scale, from just a few nodes to the full 500-node spiral.</p>
                        <p><strong>Breathing Animation</strong></p>
                        <p>The "Breathe" animation creates a natural expansion and contraction effect, mimicking the
                            rhythmic patterns found in living systems. This demonstrates how the golden ratio governs
                            not
                            just static form, but dynamic processes of growth and respiration. The spiral appears to
                            "breathe" as it scales in and out, showing how mathematical principles manifest in
                            biological
                            rhythms.</p>
                    </div>
                </div>
                <hr class="hr">
                <div class="section">
                    <h3 class="section-title">Mathematical Optimization in Living Systems</h3>
                    <div class="section-content">
                        <p><strong>The efficiency principle:</strong> Your spiral demonstrates how mathematical
                            optimization principles govern biological form. Nature "solves" complex packing problems
                            through
                            evolutionary pressure toward these mathematical ideals.</p>
                        <p>The golden angle optimizes multiple criteria simultaneously:</p>
                        <ul>
                            <li><strong>Space Utilization:</strong> Maximizes the number of elements in a given area.
                            </li>
                            <li><strong>Resource Access:</strong> Ensures each element has optimal access to sunlight
                                and
                                nutrients.</li>
                            <li><strong>Structural Stability:</strong> Distributes mechanical stress evenly across the
                                form.</li>
                        </ul>
                        <p><strong>From 2D to 3D: The Meaning of Depth</strong></p>
                        <p>Adjusting the "Depth" slider does not break the mathematical rules; it enhances them. You are
                            transforming the 2D model into a 3D cone, which is how this pattern appears on pinecones,
                            pineapples, and flowering buds. The core golden angle relationship on the XY plane remains,
                            but you are now exploring how this 2D optimization extends into a more realistic,
                            three-dimensional growth pattern.</p>
                    </div>
                </div>
                <hr class="hr">
                <div class="section">
                    <h3 class="section-title">Scale Invariance: From Seeds to Galaxies</h3>
                    <div class="section-content">
                        <p><strong>Universal principle:</strong> One of the most remarkable properties of this pattern
                            is its <strong>scale invariance</strong>—a key characteristic of fractals. It maintains its
                            essential structure at vastly different sizes.</p>
                        <p>Your "Radius" control demonstrates this directly. Whether the spiral represents sunflower
                            seeds at the millimeter scale or galaxy arms at the light-year scale, the underlying
                            mathematics remains identical.</p>
                        <p><strong>Examples Across Scales</strong></p>
                        <ul>
                            <li><strong>Microscopic:</strong> DNA double helix, virus shell structures.</li>
                            <li><strong>Biological:</strong> Sunflower seeds, pinecone scales, flower petals, nautilus
                                shells.</li>
                            <li><strong>Atmospheric & Cosmic:</strong> Hurricane structures, whirlpools, galaxy spiral
                                arms.</li>
                        </ul>
                        <p>This reveals that the rules of efficient packing and growth are universal, applying to
                            systems of all sizes across the cosmos.</p>
                    </div>
                </div>
                <hr class="hr">
                <div class="section">
                    <h3 class="section-title">Dynamic Systems: Growth and Change</h3>
                    <div class="section-content">
                        <p><strong>Living mathematics:</strong> The "Breathe" and "Node Count" animations reveal how
                            static mathematical patterns become dynamic in living systems.</p>
                        <p>Real biological systems don't simply display these patterns—they grow into them over time. A
                            sunflower doesn't create all its seeds simultaneously. Each seed appears in sequence,
                            following
                            the golden angle rule, a process simulated by the "Node Count" animation that shows the
                            spiral
                            growing from 1 to 500 nodes and back.</p>
                        <p>The "Breathe" animation demonstrates how these patterns respond to environmental changes
                            while
                            maintaining their mathematical foundation. The spiral expands and contracts like a living
                            organism, showing how the golden ratio governs not just form but also rhythm and movement.
                            This flexibility explains why the same underlying mathematics appears in such diverse
                            natural
                            contexts, from cellular respiration to cosmic expansion.</p>
                    </div>
                </div>
                <hr class="hr">
                <div class="section">
                    <h3 class="section-title">Deeper Mathematical Connections</h3>
                    <div class="section-content">
                        <p><strong>Beyond the obvious:</strong> Your spiral connects to advanced mathematical concepts
                            including number theory, optimization theory, and dynamical systems.</p>
                        <p>The complete mathematical framework encompasses several interconnected principles, all
                            stemming
                            from one unique number:</p>
                        <div class="formula">Golden Ratio: φ = (1 + &radic;5) / 2</div>
                        <div class="formula">Continued Fraction: φ = 1 + 1/(1 + 1/(1 + 1/(1 + ...)))</div>
                        <p>The golden ratio's continued fraction representation, composed entirely of ones, is the
                            simplest and slowest converging of any number. This is the deep mathematical reason why it
                            is
                            the "most irrational" number, and therefore the perfect candidate for avoiding repetition
                            and
                            creating the optimal packing seen in your spiral.</p>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // Camera Controls Class
        class CameraControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.target = new THREE.Vector3(0, -2, 0);
                this.minDistance = 10;
                this.maxDistance = 150;
                this.rotateSpeed = 0.005;
                this.zoomSpeed = 0.1;
                this.radius = this.camera.position.distanceTo(this.target);
                this.theta = Math.atan2(this.camera.position.z, this.camera.position.x);
                this.phi = Math.acos(this.camera.position.y / this.radius);
                this.isRotating = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                this.externalZoom = null;

                this.onMouseDown = this.onMouseDown.bind(this);
                this.onMouseMove = this.onMouseMove.bind(this);
                this.onMouseUp = this.onMouseUp.bind(this);
                this.onWheel = this.onWheel.bind(this);

                this.domElement.addEventListener("mousedown", this.onMouseDown);
                this.domElement.addEventListener("wheel", this.onWheel, { passive: false });
            }

            onMouseDown(event) {
                this.isRotating = true;
                this.lastMouseX = event.clientX;
                this.lastMouseY = event.clientY;
                document.addEventListener("mousemove", this.onMouseMove);
                document.addEventListener("mouseup", this.onMouseUp);
                event.preventDefault();
            }

            onMouseMove(event) {
                if (!this.isRotating) return;
                const deltaX = event.clientX - this.lastMouseX;
                const deltaY = event.clientY - this.lastMouseY;
                this.theta += deltaX * this.rotateSpeed;
                this.phi -= deltaY * this.rotateSpeed;
                this.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.phi));
                this.lastMouseX = event.clientX;
                this.lastMouseY = event.clientY;
                this.updateCamera();
                event.preventDefault();
            }

            onMouseUp(event) {
                this.isRotating = false;
                document.removeEventListener("mousemove", this.onMouseMove);
                document.removeEventListener("mouseup", this.onMouseUp);
                event.preventDefault();
            }

            onWheel(event) {
                event.preventDefault();
                if (this.externalZoom === null) {
                    const delta = event.deltaY > 0 ? 1 + this.zoomSpeed : 1 - this.zoomSpeed;
                    this.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.radius * delta));
                    this.updateCamera();
                }
            }

            updateCamera() {
                const distance = this.externalZoom !== null ? this.externalZoom : this.radius;
                const x = distance * Math.sin(this.phi) * Math.cos(this.theta);
                const y = distance * Math.cos(this.phi);
                const z = distance * Math.sin(this.phi) * Math.sin(this.theta);
                this.camera.position.set(x, y, z);
                this.camera.lookAt(this.target);
            }

            setExternalZoom(zoom) {
                this.externalZoom = zoom;
                this.updateCamera();
            }

            reset() {
                this.camera.position.set(0, 0, 70);
                this.camera.lookAt(this.target);
                this.radius = this.camera.position.distanceTo(this.target);
                this.theta = Math.atan2(this.camera.position.z, this.camera.position.x);
                this.phi = Math.acos(this.camera.position.y / this.radius);
                this.externalZoom = null;
                this.isRotating = false;
                this.updateCamera();
            }

            update() { }

            dispose() {
                this.domElement.removeEventListener("mousedown", this.onMouseDown);
                this.domElement.removeEventListener("wheel", this.onWheel);
                document.removeEventListener("mousemove", this.onMouseMove);
                document.removeEventListener("mouseup", this.onMouseUp);
            }
        }

        // Global variables
        let scene, camera, renderer, controls, clock, animationId;
        let spiralGroup, lights;
        let points = [], spheres = [], tubes = [], numberSprites = [], originalPositions = [];

        // Animation state
        let animationProgress = 0;
        let isAnimationComplete = false;
        let isOpeningClosing = false;
        let isSpinning = false;
        let isNodeCountAnimating = false;
        let showNumbers = false;

        // Animation progress tracking
        let openingClosingProgress = 0;
        let spinningAngle = 0;
        let nodeCountAnimationProgress = 0;

        // Parameters
        let radius = 1.2;
        let depth = 1.0;
        let zoom = 108;
        let numNodes = 333;
        let animationSpeed = 1.0;
        let previousNumNodes = 333;

        const defaultValues = {
            radius: 1.2,
            depth: 1.0,
            zoom: 108,
            numNodes: 333,
            animationSpeed: 1.0
        };

        // Fibonacci function
        function getFibonacciNumber(n) {
            if (n === 0) return 1;
            if (n === 1) return 1;
            let a = 1, b = 1;
            for (let i = 2; i <= n; i++) {
                const temp = a + b;
                a = b;
                b = temp;
            }
            return b;
        }

        // Create text sprite
        function createTextSprite(text, position) {
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            canvas.width = 64;
            canvas.height = 64;

            context.fillStyle = "rgba(0, 0, 0, 0)";
            context.fillRect(0, 0, 64, 64);
            context.font = "bold 23px Arial";
            context.fillStyle = "#F0F0F0";
            context.textAlign = "center";
            context.textBaseline = "middle";
            context.shadowColor = "#ffffff";
            context.shadowBlur = 2;
            context.shadowOffsetX = 1;
            context.shadowOffsetY = 1;
            context.fillText(text, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                sizeAttenuation: true,
            });

            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            sprite.scale.set(0.4, 0.4, 0.4);
            sprite.visible = false;
            return sprite;
        }

        // Create Fibonacci Spiral
        function createFibonacciSpiral() {
            console.log("Creating Fibonacci spiral...");

            if (spiralGroup) {
                spiralGroup.clear();
            }
            points.length = 0;
            spheres.length = 0;
            tubes.length = 0;
            numberSprites.length = 0;
            originalPositions.length = 0;

            const numPoints = 500;
            const initialScale = 0.75; // Increased from 0.5 to 0.75 (50% larger)
            const depthFactor = 0.1;
            const sphereRadius = 0.1;
            const tubeRadius = 0.02;
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));

            // Colors
            const color1 = new THREE.Color(0xcf9fff);
            const color2 = new THREE.Color(0xf984ef);
            const color3 = new THREE.Color(0x00ffff);
            const color4 = new THREE.Color(0xe6b3ff);
            const sphereColor = new THREE.Color(0x9fa8da);

            const sphereMaterial = new THREE.MeshStandardMaterial({
                color: sphereColor,
                metalness: 0.9,
                roughness: 0.05,
                envMapIntensity: 1.2,
            });

            for (let i = 0; i < numPoints; i++) {
                const r = initialScale * Math.sqrt(i);
                const angle = i * goldenAngle;
                const x = r * Math.cos(angle);
                const y = r * Math.sin(angle);
                const z = i * depthFactor;

                const point = new THREE.Vector3(x, y, z);
                points.push(point);

                const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(point);
                sphere.visible = false;
                spheres.push(sphere);
                originalPositions.push(point.clone());
                spiralGroup.add(sphere);

                const fibNumber = getFibonacciNumber(i);
                if (fibNumber.toString().length <= 4) {
                    const numberSprite = createTextSprite(
                        fibNumber.toString(),
                        point.clone().add(new THREE.Vector3(0, 0.2, 0))
                    );
                    numberSprites.push(numberSprite);
                    spiralGroup.add(numberSprite);
                } else {
                    const placeholderSprite = new THREE.Sprite();
                    placeholderSprite.visible = false;
                    numberSprites.push(placeholderSprite);
                }

                if (i > 0) {
                    const tubeMaterialColor = new THREE.Color();
                    const t = i / numNodes;
                    if (t < 0.33) {
                        tubeMaterialColor.lerpColors(color1, color2, t * 3);
                    } else if (t < 0.67) {
                        tubeMaterialColor.lerpColors(color2, color3, (t - 0.33) * 3);
                    } else {
                        tubeMaterialColor.lerpColors(color3, color4, (t - 0.67) * 3);
                    }

                    const tubeMaterial = new THREE.MeshStandardMaterial({
                        color: tubeMaterialColor,
                        metalness: 0.95,
                        roughness: 0.02,
                        envMapIntensity: 1.5,
                    });

                    const prevPoint = points[i - 1];
                    const tubeCurve = new THREE.LineCurve3(prevPoint, point);
                    const tubeGeometry = new THREE.TubeGeometry(tubeCurve, 2, tubeRadius, 8, false);
                    const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                    tube.visible = false;
                    tubes.push(tube);
                    spiralGroup.add(tube);
                }
            }
            console.log(`Created ${spheres.length} spheres, ${tubes.length} tubes, and ${numberSprites.length} sprites`);
        }

        // Animation loop
        function animate() {
            animationId = requestAnimationFrame(animate);
            if (!clock || !renderer || !scene || !camera) return;

            const delta = clock.getDelta();

            if (!isAnimationComplete) {
                animationProgress += delta / 0.5;
                if (animationProgress >= 1) {
                    animationProgress = 1;
                    isAnimationComplete = true;
                }

                const targetNodes = numNodes;
                const easedProgress = animationProgress < 0.5
                    ? 2 * animationProgress * animationProgress
                    : 1 - Math.pow(-2 * animationProgress + 2, 2) / 2;

                const visibleCount = easedProgress * targetNodes;

                for (let i = 0; i < 500; i++) {
                    const fadeProgress = Math.max(0, Math.min(1, (visibleCount - i) / 15));
                    const isVisible = fadeProgress > 0.1;

                    if (spheres[i]) {
                        spheres[i].visible = isVisible;
                        if (isVisible) {
                            const scale = 0.4 + 0.6 * fadeProgress;
                            spheres[i].scale.set(scale, scale, scale);
                        }
                    }

                    if (tubes[i - 1]) {
                        tubes[i - 1].visible = isVisible;
                        if (isVisible) {
                            const tubeMaterial = tubes[i - 1].material;
                            if (tubeMaterial) {
                                tubeMaterial.opacity = fadeProgress;
                                tubeMaterial.transparent = true;
                            }
                        }
                    }

                    if (numberSprites[i]) {
                        numberSprites[i].visible = isVisible && showNumbers && fadeProgress > 0.8;
                    }
                }
            } else {
                if (controls) {
                    controls.update();
                }

                // Sphere rotations
                spheres.forEach((sphere, index) => {
                    if (sphere.visible) {
                        const rotationSpeed = 0.008 + (index % 3) * 0.004;
                        sphere.rotation.x += rotationSpeed;
                        sphere.rotation.y += rotationSpeed * 1.5;
                    }
                });

                // Light animation
                const time = clock.getElapsedTime();
                if (lights) {
                    lights.mainLight.intensity = 2.0 + 0.3 * Math.sin(time * 0.3);
                    lights.specularLight.intensity = 1.5 + 0.2 * Math.cos(time * 0.5);
                    lights.fillLight.intensity = 1.2 + 0.1 * Math.sin(time * 0.4);
                }

                // Base scale - use current radius/depth values
                const baseScaleX = radius;
                const baseScaleY = radius;
                const baseScaleZ = depth;

                // Opening/Closing animation
                if (isOpeningClosing) {
                    openingClosingProgress += delta * 0.4 * animationSpeed;
                    if (openingClosingProgress > Math.PI * 2) {
                        openingClosingProgress = 0;
                    }
                    const openCloseScale = 0.3 + 0.7 * Math.sin(openingClosingProgress);
                    if (spiralGroup) {
                        const targetScale = new THREE.Vector3(
                            baseScaleX * openCloseScale,
                            baseScaleY * openCloseScale,
                            baseScaleZ * openCloseScale
                        );
                        spiralGroup.scale.lerp(targetScale, delta * 2);
                    }
                } else {
                    // Apply base scale when no animations are active
                    if (spiralGroup) {
                        const targetScale = new THREE.Vector3(baseScaleX, baseScaleY, baseScaleZ);
                        // Use immediate setting for the first few frames, then lerp
                        if (clock.getElapsedTime() < 0.1) {
                            spiralGroup.scale.copy(targetScale);
                        } else {
                            spiralGroup.scale.lerp(targetScale, delta * 3);
                        }
                    }
                }

                // Spinning animation
                if (isSpinning) {
                    spinningAngle += delta * 0.5 * animationSpeed;
                    if (spinningAngle > Math.PI * 2) {
                        spinningAngle = 0;
                    }
                    if (spiralGroup) {
                        spiralGroup.rotation.z += delta * 0.5 * animationSpeed;
                    }
                }

                // Node count animation
                if (isNodeCountAnimating) {
                    nodeCountAnimationProgress += delta * 0.6 * animationSpeed;
                    if (nodeCountAnimationProgress > Math.PI * 2) {
                        nodeCountAnimationProgress = 0;
                    }

                    const time = nodeCountAnimationProgress;
                    const primaryWave = Math.sin(time);
                    const secondaryWave = Math.sin(time * 0.5) * 0.1;
                    const combinedWave = primaryWave + secondaryWave;
                    const normalizedValue = (combinedWave + 1) / 2;
                    const smoothValue = normalizedValue * normalizedValue * (3 - 2 * normalizedValue);
                    const easedValue = Math.pow(smoothValue, 0.8);
                    const animatedNodeCount = Math.round(1 + easedValue * 499);

                    const currentCount = numNodes;
                    const targetCount = animatedNodeCount;
                    const interpolationSpeed = delta * 4;
                    const interpolatedCount = Math.round(
                        currentCount + (targetCount - currentCount) * interpolationSpeed
                    );

                    numNodes = interpolatedCount;
                    document.getElementById('nodesLabel').textContent = `nodes: ${numNodes}`;
                    document.getElementById('nodesSlider').value = numNodes;

                    updateNodeVisibility(interpolatedCount);
                }
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        // Update node visibility
        function updateNodeVisibility(nodeCount) {
            spheres.forEach((sphere, index) => {
                const isVisible = index < nodeCount;
                sphere.visible = isVisible;
                if (isVisible) {
                    const fadeProgress = Math.max(0, Math.min(1, (nodeCount - index) / 3));
                    const scale = 0.6 + 0.4 * fadeProgress;
                    sphere.scale.set(scale, scale, scale);
                }
            });

            tubes.forEach((tube, index) => {
                const isVisible = index < nodeCount - 1;
                tube.visible = isVisible;
                if (isVisible) {
                    const tubeMaterial = tube.material;
                    if (tubeMaterial) {
                        const fadeProgress = Math.max(0, Math.min(1, (nodeCount - index - 1) / 2));
                        tubeMaterial.opacity = fadeProgress;
                        tubeMaterial.transparent = true;
                    }
                }
            });

            numberSprites.forEach((sprite, index) => {
                const fibNumber = getFibonacciNumber(index);
                const isVisible = index < nodeCount && showNumbers && fibNumber.toString().length <= 4;
                sprite.visible = isVisible;
                if (isVisible) {
                    const fadeProgress = Math.max(0, Math.min(1, (nodeCount - index) / 2));
                    const scale = 0.3 + 0.1 * fadeProgress;
                    sprite.scale.set(scale, scale, scale);
                }
            });
        }

        // Handle resize
        function handleResize() {
            if (!camera || !renderer) return;
            const container = document.getElementById('container');
            if (!container) return;

            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        // Initialize scene
        function init() {
            try {
                console.log("Starting initialization...");

                const container = document.getElementById('container');
                const canvas = document.getElementById('canvas');
                if (!container || !canvas) return;

                const width = container.clientWidth;
                const height = container.clientHeight;

                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a2a);
                scene.fog = new THREE.Fog(0x1a1a2a, 60, 200);

                // Camera
                camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
                camera.position.set(0, 0, 70);
                camera.lookAt(0, -2, 0);

                // Renderer
                renderer = new THREE.WebGLRenderer({
                    antialias: false,
                    canvas: canvas
                });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = false;
                renderer.toneMapping = THREE.NoToneMapping;
                renderer.outputColorSpace = THREE.SRGBColorSpace;

                // Spiral group
                spiralGroup = new THREE.Group();
                scene.add(spiralGroup);

                // Lighting
                const mainLight = new THREE.DirectionalLight(0xfff4e6, 2.0);
                mainLight.position.set(50, 50, 50);
                scene.add(mainLight);

                const fillLight = new THREE.DirectionalLight(0x4a90e2, 1.2);
                fillLight.position.set(-30, -30, 30);
                scene.add(fillLight);

                const rimLight = new THREE.DirectionalLight(0xff6b6b, 0.8);
                rimLight.position.set(0, -50, 0);
                scene.add(rimLight);

                const specularLight = new THREE.PointLight(0xffffff, 1.5, 200);
                specularLight.position.set(0, 20, 40);
                scene.add(specularLight);

                lights = { mainLight, fillLight, rimLight, specularLight };

                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                scene.add(ambientLight);

                // Camera controls
                controls = new CameraControls(camera, renderer.domElement);

                // Generate spiral
                createFibonacciSpiral();

                // Set initial scale after creating spiral - IMPORTANT!
                console.log("Setting initial spiral scale to:", radius, radius, depth);
                spiralGroup.scale.set(radius, radius, depth);

                // Set initial visibility
                updateNodeVisibility(numNodes);

                // Clock
                clock = new THREE.Clock();

                // Event listeners
                window.addEventListener("resize", handleResize);

                // Force initial scale update
                setTimeout(() => {
                    if (spiralGroup) {
                        spiralGroup.scale.set(radius, radius, depth);
                        console.log("Forced scale update to:", spiralGroup.scale);
                    }
                }, 100);

                // Start animation
                animate();

                console.log("Initialization complete");
            } catch (error) {
                console.error("Error initializing Three.js scene:", error);
            }
        }

        // Smooth animation functions
        function animateValue(startValue, endValue, duration, callback) {
            const startTime = Date.now();
            const animate = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                const currentValue = startValue + (endValue - startValue) * easeProgress;
                callback(currentValue);
                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            };
            animate();
        }

        // Event listeners
        document.addEventListener('DOMContentLoaded', function () {
            // Initialize
            init();

            // Set initial slider values to match variables
            document.getElementById('radiusSlider').value = radius;
            document.getElementById('depthSlider').value = depth;
            document.getElementById('nodesSlider').value = numNodes;
            document.getElementById('zoomSlider').value = zoom;
            document.getElementById('speedSlider').value = animationSpeed;
            document.getElementById('nodesLabel').textContent = `nodes: ${numNodes}`;

            // Slider event listeners
            document.getElementById('radiusSlider').addEventListener('input', function (e) {
                radius = parseFloat(e.target.value);
            });

            document.getElementById('depthSlider').addEventListener('input', function (e) {
                depth = parseFloat(e.target.value);
            });

            document.getElementById('nodesSlider').addEventListener('input', function (e) {
                const newNodes = parseInt(e.target.value);
                if (!isNodeCountAnimating) {
                    numNodes = newNodes;
                    document.getElementById('nodesLabel').textContent = `nodes: ${numNodes}`;
                    if (isAnimationComplete) {
                        updateNodeVisibility(numNodes);
                    }
                }
            });

            document.getElementById('zoomSlider').addEventListener('input', function (e) {
                zoom = parseInt(e.target.value);
                if (isAnimationComplete && controls) {
                    const invertedZoom = 160 - zoom;
                    controls.setExternalZoom(invertedZoom);
                }
            });

            document.getElementById('speedSlider').addEventListener('input', function (e) {
                animationSpeed = parseFloat(e.target.value);
            });

            // Animation control buttons
            document.getElementById('infoBtn').addEventListener('click', function () {
                document.getElementById('modal').classList.add('open');
            });

            document.getElementById('resetBtn').addEventListener('click', function () {
                // Reset all values
                radius = defaultValues.radius;
                depth = defaultValues.depth;
                zoom = defaultValues.zoom;
                numNodes = defaultValues.numNodes;
                animationSpeed = defaultValues.animationSpeed;

                // Reset sliders
                document.getElementById('radiusSlider').value = radius;
                document.getElementById('depthSlider').value = depth;
                document.getElementById('nodesSlider').value = numNodes;
                document.getElementById('zoomSlider').value = zoom;
                document.getElementById('speedSlider').value = animationSpeed;
                document.getElementById('nodesLabel').textContent = `nodes: ${numNodes}`;

                // Reset animations
                isOpeningClosing = false;
                isSpinning = false;
                isNodeCountAnimating = false;
                showNumbers = false;

                // Reset button states
                document.querySelectorAll('.control-button').forEach(btn => {
                    if (!btn.id.includes('info') && !btn.id.includes('reset')) {
                        btn.classList.remove('active');
                    }
                });

                // Reset camera
                if (controls) {
                    controls.reset();
                }

                // Reset spiral scale
                if (spiralGroup) {
                    spiralGroup.scale.set(radius, radius, depth);
                    spiralGroup.rotation.set(0, 0, 0);
                }

                // Update visibility
                if (isAnimationComplete) {
                    updateNodeVisibility(numNodes);
                }
            });

            document.getElementById('breatheBtn').addEventListener('click', function () {
                isOpeningClosing = !isOpeningClosing;
                this.classList.toggle('active');
            });

            document.getElementById('spinBtn').addEventListener('click', function () {
                isSpinning = !isSpinning;
                this.classList.toggle('active');
            });

            document.getElementById('nodeCountBtn').addEventListener('click', function () {
                isNodeCountAnimating = !isNodeCountAnimating;
                this.classList.toggle('active');
                if (isNodeCountAnimating) {
                    nodeCountAnimationProgress = 0;
                }
            });

            document.getElementById('numbersBtn').addEventListener('click', function () {
                showNumbers = !showNumbers;
                this.classList.toggle('active');

                if (showNumbers) {
                    // Store current values
                    previousNumNodes = numNodes;

                    // Adjust target position for closer zoom
                    if (controls) {
                        controls.target.set(0, 0.5, 0);
                        controls.updateCamera();
                    }

                    // Find max displayable Fibonacci number
                    let maxFibIndex = 0;
                    for (let i = 0; i < 1000; i++) {
                        const fibNumber = getFibonacciNumber(i);
                        if (fibNumber < 10000) {
                            maxFibIndex = i + 1;
                        } else {
                            break;
                        }
                    }

                    // Animate to new values
                    animateValue(numNodes, maxFibIndex, 1000, (value) => {
                        numNodes = Math.round(value);
                        document.getElementById('nodesLabel').textContent = `nodes: ${numNodes}`;
                        document.getElementById('nodesSlider').value = numNodes;
                        if (isAnimationComplete) {
                            updateNodeVisibility(numNodes);
                        }
                    });

                    animateValue(zoom, 150, 800, (value) => {
                        zoom = Math.round(value);
                        document.getElementById('zoomSlider').value = zoom;
                        if (isAnimationComplete && controls) {
                            const invertedZoom = 160 - zoom;
                            controls.setExternalZoom(invertedZoom);
                            controls.updateCamera();
                        }
                    });
                } else {
                    // Restore original target position
                    if (controls) {
                        controls.target.set(0, -2, 0);
                        controls.updateCamera();
                    }

                    // Animate back to previous values
                    animateValue(numNodes, previousNumNodes, 1000, (value) => {
                        numNodes = Math.round(value);
                        document.getElementById('nodesLabel').textContent = `nodes: ${numNodes}`;
                        document.getElementById('nodesSlider').value = numNodes;
                        if (isAnimationComplete) {
                            updateNodeVisibility(numNodes);
                        }
                    });

                    animateValue(zoom, defaultValues.zoom, 800, (value) => {
                        zoom = Math.round(value);
                        document.getElementById('zoomSlider').value = zoom;
                        if (isAnimationComplete && controls) {
                            const invertedZoom = 160 - zoom;
                            controls.setExternalZoom(invertedZoom);
                            controls.updateCamera();
                        }
                    });
                }
            });

            // Modal controls
            document.getElementById('closeModal').addEventListener('click', function () {
                document.getElementById('modal').classList.remove('open');
            });

            document.getElementById('closeModalBottom').addEventListener('click', function () {
                document.getElementById('modal').classList.remove('open');
            });

            document.getElementById('modal').addEventListener('click', function (e) {
                if (e.target === this) {
                    this.classList.remove('open');
                }
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', function (e) {
                switch (e.key) {
                    case 'Escape':
                        document.getElementById('modal').classList.remove('open');
                        break;
                    case 'i':
                        document.getElementById('modal').classList.add('open');
                        break;
                    case 'r':
                        document.getElementById('resetBtn').click();
                        break;
                    case 'b':
                        document.getElementById('breatheBtn').click();
                        break;
                    case 's':
                        document.getElementById('spinBtn').click();
                        break;
                    case 'c':
                        document.getElementById('nodeCountBtn').click();
                        break;
                    case 'n':
                        document.getElementById('numbersBtn').click();
                        break;
                }
            });
        });
    </script>
</body>

</html>
